<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharpx.Collections.Experimental</name></assembly>
<members>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.AltBinRndAccList`1.Uncons">
<summary>
O(log n). Returns the first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.AltBinRndAccList`1.TryUncons">
<summary>
O(log n). Returns the option first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.AltBinRndAccList`1.TryGetTail">
<summary>
O(log n). Returns a option random access list of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.AltBinRndAccList`1.Tail">
<summary>
O(log n). Returns a new random access list of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.AltBinRndAccList`1.IsEmpty">
<summary>
O(1). Returns true if the random access list has no elements.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.AltBinRndAccList`1.Head">
<summary>
O(log n). Returns the first element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.AltBinRndAccList`1.Update(System.Int32,`0)">
<summary>
O(log n). Returns random access list with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.AltBinRndAccList`1.TryUpdate(System.Int32,`0)">
<summary>
O(log n). Returns option random access list with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.AltBinRndAccList`1.TryRemove(System.Int32)">
<summary>
O(n). Returns option random access list with element removed by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.AltBinRndAccList`1.TryLookup(System.Int32)">
<summary>
O(log n). Returns option element by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.AltBinRndAccList`1.TryGetHead">
<summary>
O(log n). Returns option first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.AltBinRndAccList`1.Rev">
<summary>
O(n). Returns random access list reversed.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.AltBinRndAccList`1.Remove(System.Int32)">
<summary>
O(n). Returns random access list with element removed by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.AltBinRndAccList`1.Lookup(System.Int32)">
<summary>
O(log n). Returns element by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.AltBinRndAccList`1.Length">
<summary>
O(log n). Returns the count of elememts.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.AltBinRndAccList`1.Cons(`0)">
<summary>
O(log n). Returns a new random access list with the element added to the beginning.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BankersDeque`1.Unsnoc">
<summary>
O(1), amortized. Returns init and the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BankersDeque`1.Uncons">
<summary>
O(1), amortized. Returns the first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BankersDeque`1.TryUnsnoc">
<summary>
O(1), amortized. Returns option init and the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BankersDeque`1.TryUncons">
<summary>
O(1), amortized. Returns option first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BankersDeque`1.TryGetTail">
<summary>
O(1), amortized. Returns option deque of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BankersDeque`1.TryGetLast">
<summary>
O(1), amortized. Returns option last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BankersDeque`1.TryGetInit">
<summary>
O(1), amortized. Returns option deque of the elements before the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BankersDeque`1.TryGetHead">
<summary>
O(1), amortized. Returns option first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BankersDeque`1.Tail">
<summary>
O(1), amortized. Returns a new deque of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BankersDeque`1.Rev">
<summary>
O(1). Returns deque reversed.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BankersDeque`1.Length">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BankersDeque`1.Last">
<summary>
O(1), amortized. Returns the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BankersDeque`1.IsEmpty">
<summary>
O(1). Returns true if the deque has no elements.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BankersDeque`1.Init">
<summary>
O(1), amortized. Returns a new deque of the elements before the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BankersDeque`1.Head">
<summary>
O(1), amortized. Returns the first element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BankersDeque`1.Update(System.Int32,`0)">
<summary>
O(n), worst case. Returns deque with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BankersDeque`1.TryUpdate(System.Int32,`0)">
<summary>
O(n), worst case. Returns option deque with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BankersDeque`1.TryRemove(System.Int32)">
<summary>
O(n), worst case. Returns option deque with element removed by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BankersDeque`1.TryLookup(System.Int32)">
<summary>
O(n), worst case. Returns option element by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BankersDeque`1.Snoc(`0)">
<summary>
O(1), amortized. Returns a new deque with the element added to the end.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BankersDeque`1.Remove(System.Int32)">
<summary>
O(n), worst case. Returns deque with element removed by index.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BankersDeque`1.Lookup(System.Int32)">
<summary>
O(n), worst case. Returns element by index.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BankersDeque`1.Cons(`0)">
<summary>
O(1), amortized. Returns a new deque with the element added to the beginning.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BankersQueue`1.Uncons">
<summary>
O(1), amortized. Returns the first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BankersQueue`1.TryUncons">
<summary>
O(1), amortized. Returns option first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BankersQueue`1.TryGetTail">
<summary>
O(1), amortized. Returns option queue of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BankersQueue`1.TryGetHead">
<summary>
O(1), amortized. Returns option first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BankersQueue`1.Tail">
<summary>
O(1), amortized. Returns a new queue of the elements trailing the first element.
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.BankersQueue`1.Rev">
<summary>
O(1). Returns queue reversed
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.BankersQueue`1.Length">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BankersQueue`1.IsEmpty">
<summary>
O(1). Returns true if the queue has no elements.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BankersQueue`1.Head">
<summary>
O(1), amortized. Returns the first element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BankersQueue`1.Snoc(`0)">
<summary>
O(1), amortized. Returns a new queue with the element added to the end.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BatchedDeque`1.Unsnoc">
<summary>
O(1) amortized, O(n), worst case. Returns init and the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BatchedDeque`1.Uncons">
<summary>
O(1) amortized, O(n), worst case. Returns the first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BatchedDeque`1.TryUnsnoc">
<summary>
O(1) amortized, O(n), worst case. Returns option init and the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BatchedDeque`1.TryUncons">
<summary>
O(1) amortized, O(n), worst case. Returns option first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BatchedDeque`1.TryGetTail">
<summary>
O(1) amortized, O(n), worst case. Returns option deque of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BatchedDeque`1.TryGetLast">
<summary>
O(1) amortized, O(n), worst case. Returns option last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BatchedDeque`1.TryGetInit">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque of the elements before the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BatchedDeque`1.TryGetHead">
<summary>
O(1) amortized, O(n), worst case. Returns option first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BatchedDeque`1.Tail">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BatchedDeque`1.Rev">
<summary>
O(1). Returns deque reversed.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BatchedDeque`1.Length">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BatchedDeque`1.Last">
<summary>
O(1) amortized, O(n), worst case. Returns the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BatchedDeque`1.IsEmpty">
<summary>
O(1). Returns true if the deque has no elements.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BatchedDeque`1.Init">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque of the elements before the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BatchedDeque`1.Head">
<summary>
O(1) amortized, O(n), worst case. Returns the first element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDeque`1.Update(System.Int32,`0)">
<summary>
O(n), worst case. Returns deque with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDeque`1.TryUpdate(System.Int32,`0)">
<summary>
O(n), worst case. Returns option deque with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDeque`1.TryRemove(System.Int32)">
<summary>
O(n), worst case. Returns option deque with element removed by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDeque`1.TryLookup(System.Int32)">
<summary>
O(n), worst case. Returns option element by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDeque`1.Snoc(`0)">
<summary>
O(1). Returns a new deque with the element added to the end.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDeque`1.Remove(System.Int32)">
<summary>
O(n), worst case. Returns deque with element removed by index.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDeque`1.Lookup(System.Int32)">
<summary>
O(n), worst case. Returns element by index.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDeque`1.Cons(`0)">
<summary>
O(1). Returns a new deque with the element added to the beginning.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BatchedQueue`1.Uncons">
<summary>
returns the first element and tail
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BatchedQueue`1.TryUncons">
<summary>
returns option first element and tail
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BatchedQueue`1.TryGetTail">
<summary>
returns option queue of the elements trailing the first element
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BatchedQueue`1.TryGetHead">
<summary>
returns option first element
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BatchedQueue`1.Tail">
<summary>
returns a new queue of the elements trailing the first element
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.BatchedQueue`1.Rev">
<summary>
returns queue reversed
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.BatchedQueue`1.Length">
<summary>
returns the count of elememts
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BatchedQueue`1.IsEmpty">
<summary>
returns true if the queue has no elements
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BatchedQueue`1.Head">
<summary>
returns the first element
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BatchedQueue`1.Snoc(`0)">
<summary>
returns a new queue with the element added to the end
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BinaryRandomAccessList`1.Uncons">
<summary>
O(log n), worst case. Returns the first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BinaryRandomAccessList`1.TryUncons">
<summary>
O(log n), worst case. Returns the option first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BinaryRandomAccessList`1.TryGetTail">
<summary>
O(log n), worst case. Returns a option random access list of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BinaryRandomAccessList`1.TryGetHead">
<summary>
O(log n), worst case. Returns option first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BinaryRandomAccessList`1.Tail">
<summary>
O(log n), worst case. Returns a new random access list of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BinaryRandomAccessList`1.IsEmpty">
<summary>
O(1). Returns true if the random access list has no elements.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BinaryRandomAccessList`1.Head">
<summary>
O(log n), worst case. Returns the first element.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BinaryRandomAccessList`1.Update(System.Int32,`0)">
<summary>
O(log n), worst case. Returns random access list with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BinaryRandomAccessList`1.TryUpdate(System.Int32,`0)">
<summary>
O(log n), worst case. Returns option random access list with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BinaryRandomAccessList`1.TryLookup(System.Int32)">
<summary>
O(log n), worst case. Returns option element by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BinaryRandomAccessList`1.Rev">
<summary>
O(n). Returns random access list reversed.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BinaryRandomAccessList`1.Lookup(System.Int32)">
<summary>
O(log n), worst case. Returns element by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BinaryRandomAccessList`1.Length">
<summary>
O(log n). Returns the count of elememts.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BinaryRandomAccessList`1.Cons(`0)">
<summary>
O(log n), worst case. Returns a new random access list with the element added to the beginning.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BinomialHeap`1.IsEmpty">
<summary>
O(1). Returns true if the heap has no elements.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.BinomialHeap`1.IsDescending">
<summary>
O(1). Returns true if the heap has max element at head.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BinomialHeap`1.Uncons">
<summary>
O(log n). Returns the head element and tail.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BinomialHeap`1.TryUncons">
<summary>
O(log n). Returns option head element and tail.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BinomialHeap`1.TryMerge(FSharpx.Collections.Experimental.BinomialHeap{`0})">
<summary>
O(log n). Returns heap option from merging two heaps.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BinomialHeap`1.TryGetTail">
<summary>
O(log n). Returns option heap of the elements trailing the head.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BinomialHeap`1.TryGetHead">
<summary>
O(log n). Returns option first min or max element.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BinomialHeap`1.Tail">
<summary>
O(log n). Returns a new heap of the elements trailing the head.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BinomialHeap`1.Merge(FSharpx.Collections.Experimental.BinomialHeap{`0})">
<summary>
O(log n). Returns heap from merging two heaps, both must have same isDescending.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BinomialHeap`1.Length">
<summary>
O(log n). Returns the count of elememts.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BinomialHeap`1.Insert(`0)">
<summary>
O(log n). Returns a new heap with the element inserted.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BinomialHeap`1.Head">
<summary>
O(log n). Returns the min or max element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.DList`1.snoc(`0)">
<summary>
O(1). Returns a new DList with the element added to the end.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.DList`1.Tail">
<summary>
O(log n). Returns a new DList of the elements trailing the first element.
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.DList`1.Length">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.DList`1.IsEmpty">
<summary>
O(1). Returns true if the DList has no elements.
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.DList`1.Head">
<summary>
O(log n). Returns the first element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.DList`1">
<summary>
 The DList is an implementation of John Hughes&apos; append list.
 See http://dl.acm.org/citation.cfm?id=8475 for more information.
 This implementation adds an additional parameter to allow a more
 efficient calculation of the list length.
 Note that an alternate form would represent the DList as:
 type DList&lt;&apos;a&gt; = DList of (&apos;a list -&gt; &apos;a list)
 An example can be found at http://stackoverflow.com/questions/5324623/functional-o1-append-and-on-iteration-from-first-element-list-data-structure/5327209#5327209
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.Deque`1.Unsnoc">
<summary>
O(1) amortized, O(n), worst case. Returns init and the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.Deque`1.Uncons">
<summary>
O(1) amortized, O(n), worst case. Returns the first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.Deque`1.TryUnsnoc">
<summary>
O(1) amortized, O(n), worst case. Returns option init and the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.Deque`1.TryUncons">
<summary>
O(1) amortized, O(n), worst case. Returns option first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.Deque`1.TryGetTail">
<summary>
O(1) amortized, O(n), worst case. Returns option deque of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.Deque`1.TryGetLast">
<summary>
O(1) amortized, O(n), worst case. Returns option last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.Deque`1.TryGetInit">
<summary>
O(1) amortized, O(n), worst case. Returns option deque of the elements before the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.Deque`1.TryGetHead">
<summary>
O(1) amortized, O(n), worst case. Returns option first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.Deque`1.Tail">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.Deque`1.Rev">
<summary>
O(1). Returns deque reversed.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.Deque`1.Length">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.Deque`1.Last">
<summary>
O(1) amortized, O(n), worst case. Returns the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.Deque`1.IsEmpty">
<summary>
O(1). Returns true if the deque has no elements.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.Deque`1.Init">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque of the elements before the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.Deque`1.Head">
<summary>
O(1) amortized, O(n), worst case. Returns the first element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.Deque`1.Update(System.Int32,`0)">
<summary>
O(n), worst case. Returns deque with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.Deque`1.TryUpdate(System.Int32,`0)">
<summary>
O(n), worst case. Returns option deque with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.Deque`1.TryRemove(System.Int32)">
<summary>
O(n), worst case. Returns option deque with element removed by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.Deque`1.TryLookup(System.Int32)">
<summary>
O(n), worst case. Returns option element by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.Deque`1.Snoc(`0)">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque with the element added to the end.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.Deque`1.Remove(System.Int32)">
<summary>
O(n), worst case. Returns deque with element removed by index.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.Deque`1.Lookup(System.Int32)">
<summary>
O(n), worst case. Returns element by index.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.Deque`1.Cons(`0)">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque with the element added to the beginning.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.HoodMelvilleQueue`1.Uncons">
<summary>
returns the first element and tail
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.HoodMelvilleQueue`1.TryUncons">
<summary>
returns option first element and tail
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.HoodMelvilleQueue`1.TryGetTail">
<summary>
returns option queue of the elements trailing the first element
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.HoodMelvilleQueue`1.TryGetHead">
<summary>
returns option first element
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.HoodMelvilleQueue`1.Tail">
<summary>
returns a new queue of the elements trailing the first element
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.HoodMelvilleQueue`1.Length">
<summary>
returns the count of elememts
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.HoodMelvilleQueue`1.IsEmpty">
<summary>
returns true if the queue has no elements
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.HoodMelvilleQueue`1.Head">
<summary>
returns the first element
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.HoodMelvilleQueue`1.Snoc(`0)">
<summary>
returns a new queue with the element added to the end
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.LeftistHeap`1.TryGetHead">
<summary>
O(1). Returns option first min or max element.
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.LeftistHeap`1.Length">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.LeftistHeap`1.IsEmpty">
<summary>
O(1). Returns true if the heap has no elements.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.LeftistHeap`1.IsDescending">
<summary>
O(1). Returns true if the heap has max element at head.
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.LeftistHeap`1.Head">
<summary>
O(1). Returns the min or max element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.LeftistHeap`1.Uncons">
<summary>
O(log n). Returns the head element and tail.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.LeftistHeap`1.TryUncons">
<summary>
O(log n). Returns option head element and tail.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.LeftistHeap`1.TryMerge(FSharpx.Collections.Experimental.LeftistHeap{`0})">
<summary>
O(log n). Returns heap option from merging two heaps
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.LeftistHeap`1.TryGetTail">
<summary>
O(log n). Returns option heap of the elements trailing the head.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.LeftistHeap`1.Tail">
<summary>
O(log n) Returns a new heap of the elements trailing the head.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.LeftistHeap`1.Merge(FSharpx.Collections.Experimental.LeftistHeap{`0})">
<summary>
O(log n). Returns heap from merging two heaps, both must have same isDescending.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.LeftistHeap`1.Insert(`0)">
<summary>
O(log n). Returns a new heap with the element inserted.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.PairingHeap`1.IsEmpty">
<summary>
O(1) Returns true if the heap has no elements.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.PairingHeap`1.IsDescending">
<summary>
O(1). Returns true if the heap has max element at head.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.PairingHeap`1.Uncons">
<summary>
O(log n) amortized time. Returns the head element and tail.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.PairingHeap`1.TryUncons">
<summary>
O(log n) amortized time. Returns option head element and tail.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.PairingHeap`1.TryMerge(FSharpx.Collections.Experimental.PairingHeap{`0})">
<summary>
O(log n) amortized time. Returns heap option from merging two heaps.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.PairingHeap`1.TryGetTail">
<summary>
O(log n) amortized time. Returns option heap of the elements trailing the head.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.PairingHeap`1.TryGetHead">
<summary>
O(1) worst case. Returns option first min or max element.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.PairingHeap`1.Tail">
<summary>
O(log n) amortized time. Returns a new heap of the elements trailing the head.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.PairingHeap`1.Merge(FSharpx.Collections.Experimental.PairingHeap{`0})">
<summary>
O(log n) amortized time. Returns heap from merging two heaps, both must have same descending.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.PairingHeap`1.Length">
<summary>
O(n). Returns the count of elememts.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.PairingHeap`1.Insert(`0)">
<summary>
O(log n) amortized time. Returns a new heap with the element inserted.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.PairingHeap`1.Head">
<summary>
O(1) worst case. Returns the min or max element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.PairingHeap`1">
<summary>
 PairingHeap performs extremely well in practice, however (according to Okasaki) it should be avoided for applications taking advantage of persistence.
 Also according to Okasaki the time complexity of the heap functions in the PairingHeap implementation have &quot;resisted&quot; time complexity analysis. 
 ofSeq: superior performance; insert: superior performance; tail: superior performance
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.PhysicistQueue`1.Uncons">
<summary>
O(1), amortized. Returns the first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.PhysicistQueue`1.TryUncons">
<summary>
O(1), amortized. Returns option first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.PhysicistQueue`1.TryGetTail">
<summary>
O(1), amortized. Returns option queue of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.PhysicistQueue`1.TryGetHead">
<summary>
O(1), amortized. Returns option first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.PhysicistQueue`1.Tail">
<summary>
O(1), amortized. Returns a new queue of the elements trailing the first element.
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.PhysicistQueue`1.Rev">
<summary>
O(1). Returns queue reversed.
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.PhysicistQueue`1.Length">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.PhysicistQueue`1.IsEmpty">
<summary>
O(1). Returns true if the queue has no elements.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.PhysicistQueue`1.Head">
<summary>
O(1), amortized. Returns the first element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.PhysicistQueue`1.Snoc(`0)">
<summary>
O(1), amortized. Returns a new queue with the element added to the end.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.RealTimeDeque`1.Unsnoc">
<summary>
O(1), worst case. Returns init and the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.RealTimeDeque`1.Uncons">
<summary>
O(1), worst case. Returns the first element and tail
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.RealTimeDeque`1.TryUnsnoc">
<summary>
O(1), worst case. Returns option init and the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.RealTimeDeque`1.TryUncons">
<summary>
O(1), worst case. Returns option first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.RealTimeDeque`1.TryGetTail">
<summary>
O(1), worst case. Returns option deque of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.RealTimeDeque`1.TryGetLast">
<summary>
O(1), worst case. Returns option last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.RealTimeDeque`1.TryGetInit">
<summary>
O(1), worst case. Returns option deque of the elements before the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.RealTimeDeque`1.TryGetHead">
<summary>
O(1), worst case. Returns option first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.RealTimeDeque`1.Tail">
<summary>
O(1), worst case. Returns a new deque of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.RealTimeDeque`1.Rev">
<summary>
O(1). Returns deque reversed.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.RealTimeDeque`1.Length">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.RealTimeDeque`1.Last">
<summary>
O(1), worst case. Returns the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.RealTimeDeque`1.IsEmpty">
<summary>
O(1). Returns true if the deque has no elements.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.RealTimeDeque`1.Init">
<summary>
O(1), worst case. Returns a new deque of the elements before the last element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.RealTimeDeque`1.Head">
<summary>
O(1), worst case. Returns the first element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque`1.Update(System.Int32,`0)">
<summary>
O(n/2), worst case. Returns deque with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque`1.TryUpdate(System.Int32,`0)">
<summary>
O(n/2), worst case. Returns option deque with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque`1.TryRemove(System.Int32)">
<summary>
O(n/2), worst case. Returns option deque with element removed by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque`1.TryLookup(System.Int32)">
<summary>
O(n/2), worst case. Returns option element by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque`1.Snoc(`0)">
<summary>
O(1), worst case. Returns a new deque with the element added to the end.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque`1.Remove(System.Int32)">
<summary>
O(n/2), worst case. Returns deque with element removed by index.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque`1.Lookup(System.Int32)">
<summary>
O(n/2), worst case. Returns element by index.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque`1.Cons(`0)">
<summary>
O(1), worst case. Returns a new deque with the element added to the beginning.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.RingBuffer`1.TryAdvance(System.Int32)">
<summary>
 Tries to advance the position of the RingBuffer by the offset.
 Returns None if offset is negative, otherwise Some containing 
 the position of the RingBuffer.    
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.RingBuffer`1.Advance(System.Int32)">
<summary>
 Advances the position of the RingBuffer by the offset.
 Returns the position of the RingBuffer. Throws an ArgumentException if
 the offset is negative.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.RoseTree`1">
<summary>
 Multi-way tree, also known as rose tree.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.SkewBinaryRandomAccessList`1.Uncons">
<summary>
O(1), worst case. Returns the first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.SkewBinaryRandomAccessList`1.TryUncons">
<summary>
O(1), worst case. Returns the option first element and tail.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.SkewBinaryRandomAccessList`1.TryGetTail">
<summary>
O(1), worst case. Returns a option random access list of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.SkewBinaryRandomAccessList`1.TryGetHead">
<summary>
O(1), worst case. Returns option first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.SkewBinaryRandomAccessList`1.Tail">
<summary>
O(1), worst case. Returns a new random access list of the elements trailing the first element.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.SkewBinaryRandomAccessList`1.IsEmpty">
<summary>
O(1). Returns true if the random access list has no elements.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.SkewBinaryRandomAccessList`1.Head">
<summary>
O(1), worst case. Returns the first element.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.SkewBinaryRandomAccessList`1.Update(System.Int32,`0)">
<summary>
O(log n), worst case. Returns random access list with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.SkewBinaryRandomAccessList`1.TryUpdate(System.Int32,`0)">
<summary>
O(log n), worst case. Returns option random access list with element updated by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.SkewBinaryRandomAccessList`1.TryLookup(System.Int32)">
<summary>
O(log n), worst case. Returns option element by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.SkewBinaryRandomAccessList`1.Rev">
<summary>
O(n). Returns random access list reversed.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.SkewBinaryRandomAccessList`1.Lookup(System.Int32)">
<summary>
O(log n), worst case. Returns element by index.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.SkewBinaryRandomAccessList`1.Length">
<summary>
O(log n) Returns the count of elememts.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.SkewBinaryRandomAccessList`1.Cons(`0)">
<summary>
O(1), worst case. Returns a new random access list with the element added to the beginning.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.Timeseries`1.TryAdvance(System.DateTimeOffset)">
<summary>
 Tries to advance the start date of the Timeseries to toDate.
 Returns None if toDate is before the start date of the Timeseries, 
 otherwise Some containing the start date of the Timeseries.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.Timeseries`1.Advance(System.DateTimeOffset)">
<summary>
 Advances the start date of the Timeseries to toDate. Throws an 
 ArgumentException if toDate is before the Timeseries start date.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.AltBinaryRandomAccessListModule.tryUpdate``1(System.Int32,``0,FSharpx.Collections.Experimental.AltBinRndAccList{``0})">
<summary>
O(log n). Returns option random access list with element updated by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.AltBinaryRandomAccessListModule.update``1(System.Int32,``0,FSharpx.Collections.Experimental.AltBinRndAccList{``0})">
<summary>
O(log n). Returns random access list with element updated by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.AltBinaryRandomAccessListModule.tryUncons``1(FSharpx.Collections.Experimental.AltBinRndAccList{``0})">
<summary>
O(log n). Returns the option first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.AltBinaryRandomAccessListModule.uncons``1(FSharpx.Collections.Experimental.AltBinRndAccList{``0})">
<summary>
O(log n). Returns the first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.AltBinaryRandomAccessListModule.tryGetTail``1(FSharpx.Collections.Experimental.AltBinRndAccList{``0})">
<summary>
O(log n). Returns a option random access list of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.AltBinaryRandomAccessListModule.tail``1(FSharpx.Collections.Experimental.AltBinRndAccList{``0})">
<summary>
O(log n). Returns a new random access list of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.AltBinaryRandomAccessListModule.rev``1(FSharpx.Collections.Experimental.AltBinRndAccList{``0})">
<summary>
O(n). Returns random access list reversed.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.AltBinaryRandomAccessListModule.tryRemove``1(System.Int32,FSharpx.Collections.Experimental.AltBinRndAccList{``0})">
<summary>
O(n). Returns option random access list with element removed by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.AltBinaryRandomAccessListModule.remove``1(System.Int32,FSharpx.Collections.Experimental.AltBinRndAccList{``0})">
<summary>
O(n). Returns random access list with element removed by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.AltBinaryRandomAccessListModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
O(n). Returns random access list from the sequence.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.AltBinaryRandomAccessListModule.tryLookup``1(System.Int32,FSharpx.Collections.Experimental.AltBinRndAccList{``0})">
<summary>
O(log n). Returns option element by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.AltBinaryRandomAccessListModule.lookup``1(System.Int32,FSharpx.Collections.Experimental.AltBinRndAccList{``0})">
<summary>
O(log n). Returns element by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.AltBinaryRandomAccessListModule.length``1(FSharpx.Collections.Experimental.AltBinRndAccList{``0})">
<summary>
O(log n). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.AltBinaryRandomAccessListModule.isEmpty``1(FSharpx.Collections.Experimental.AltBinRndAccList{``0})">
<summary>
O(1). Returns true if the random access list has no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.AltBinaryRandomAccessListModule.tryGetHead``1(FSharpx.Collections.Experimental.AltBinRndAccList{``0})">
<summary>
O(log n). Returns option first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.AltBinaryRandomAccessListModule.empty``1">
<summary>
O(1). Returns a empty random access list.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.AltBinaryRandomAccessListModule.head``1(FSharpx.Collections.Experimental.AltBinRndAccList{``0})">
<summary>
O(log n). Returns the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.AltBinaryRandomAccessListModule.cons``1(``0,FSharpx.Collections.Experimental.AltBinRndAccList{``0})">
<summary>
O(log n). Returns a new random access list with the element added to the beginning.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.AltBinaryRandomAccessListModule.append``1(FSharpx.Collections.Experimental.AltBinRndAccList{``0},FSharpx.Collections.Experimental.AltBinRndAccList{``0})">
<summary>
O(xs). Returns random access list from elements of 2 random access lists concatenated.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.AltBinaryRandomAccessListModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.AssemblyInfo">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.BKTree">

</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.tryUpdate``1(System.Int32,``0,FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(n), worst case. Returns option deque with element updated by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.update``1(System.Int32,``0,FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(n), worst case. Returns deque with element updated by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.tryUnsnoc``1(FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(1), amortized. Returns option init and the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.unsnoc``1(FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(1), amortized. Returns init and the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.tryUncons``1(FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(1), amortized. Returns option first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.uncons``1(FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(1), amortized. Returns the first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.tryGetTail``1(FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(1), amortized. Returns option deque of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.tail``1(FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(1), amortized. Returns a new deque of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.snoc``1(``0,FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(1), amortized. Returns a new deque with the element added to the end.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.singletonC``1(System.Int32,``0)">
<summary>
O(1). Returns a deque of one element, c is front-back stream ratio constant, should be at least 2.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.singleton``1(``0)">
<summary>
O(1). Returns a deque of one element, front-back stream ratio constant defaulted to 2.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.rev``1(FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(1). Returns deque reversed.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.tryRemove``1(System.Int32,FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(n), worst case. Returns option deque with element removed by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.remove``1(System.Int32,FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(n), worst case. Returns deque with element removed by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.ofSeqC``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
O(1). Returns a deque of the seq, c is front-back stream ratio constant, should be at least 2.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
O(1). Returns a deque of the seq, front-back stream ratio constant defaulted to 2.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.ofCatSeqsC``1(System.Int32,System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
O(ys). Returns a deque of the two seqs concatenated, c is front-back stream ratio constant, should be at least 2.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.ofCatSeqs``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
O(ys). Returns a deque of the two seqs concatenated, front-back stream ratio constant defaulted to 2.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.ofCatListsC``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
O(ys-xs). Returns a deque of the two lists concatenated, c is front-back stream ration constant, should be at least 2.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.ofCatLists``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
O(ys-xs). Returns a deque of the two lists concatenated, front-back stream ratio constant defaulted to 2.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.tryLookup``1(System.Int32,FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(n), worst case. Returns option element by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.lookup``1(System.Int32,FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(n), worst case. Returns element by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.length``1(FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.tryGetLast``1(FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(1), amortized. Returns option last element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.last``1(FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(1), amortized. Returns the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.isEmpty``1(FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(1). Returns true if the deque has no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.tryGetInit``1(FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(1), amortized. Returns option deque of the elements before the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.init``1(FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(1), amortized. Returns a new deque of the elements before the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.tryGetHead``1(FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(1), amortized. Returns option first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.head``1(FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(1), amortized. Returns the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.empty``1(System.Int32)">
<summary>
O(1). Returns deque of no elements, c is front-back stream ration constant, should be at least 2.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.cons``1(``0,FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(1), amortized. Returns a new deque with the element added to the beginning.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.appendC``1(System.Int32,FSharpx.Collections.Experimental.BankersDeque{``0},FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(ys-xs). Returns a deque of the two deques concatenated, c is front-back stream ratio constant, should be at least 2.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersDequeModule.append``1(FSharpx.Collections.Experimental.BankersDeque{``0},FSharpx.Collections.Experimental.BankersDeque{``0})">
<summary>
O(ys-xs). Returns a deque of the two deques concatenated, front-back stream ratio constant defaulted to 2.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.BankersDequeModule">

</member>
<member name="M:FSharpx.Collections.Experimental.BankersQueueModule.tryUncons``1(FSharpx.Collections.Experimental.BankersQueue{``0})">
<summary>
O(1), amortized. Returns option first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersQueueModule.uncons``1(FSharpx.Collections.Experimental.BankersQueue{``0})">
<summary>
O(1), amortized. Returns the first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersQueueModule.tryGetTail``1(FSharpx.Collections.Experimental.BankersQueue{``0})">
<summary>
O(1), amortized. Returns option queue of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersQueueModule.tail``1(FSharpx.Collections.Experimental.BankersQueue{``0})">
<summary>
O(1), amortized. Returns a new queue of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersQueueModule.snoc``1(``0,FSharpx.Collections.Experimental.BankersQueue{``0})">
<summary>
O(1), amortized. Returns a new queue with the element added to the end.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersQueueModule.rev``1(FSharpx.Collections.Experimental.BankersQueue{``0})">
<summary>
O(1). Returns queue reversed.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersQueueModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
O(1). Returns a queue of the seq.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersQueueModule.length``1(Microsoft.FSharp.Core.Unit,FSharpx.Collections.Experimental.BankersQueue{``0})">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersQueueModule.isEmpty``1(Microsoft.FSharp.Core.Unit,FSharpx.Collections.Experimental.BankersQueue{``0})">
<summary>
O(1). Returns true if the queue has no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersQueueModule.tryGetHead``1(FSharpx.Collections.Experimental.BankersQueue{``0})">
<summary>
O(1), amortized. Returns option first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersQueueModule.head``1(FSharpx.Collections.Experimental.BankersQueue{``0})">
<summary>
O(1), amortized. Returns the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BankersQueueModule.empty``1">
<summary>
O(1). Returns queue of no elements.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.BankersQueueModule">

</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.tryUpdate``1(System.Int32,``0,FSharpx.Collections.Experimental.BatchedDeque{``0})">
<summary>
O(n), worst case. Returns option deque with element updated by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.update``1(System.Int32,``0,FSharpx.Collections.Experimental.BatchedDeque{``0})">
<summary>
O(n), worst case. Returns deque with element updated by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.tryUnsnoc``1(FSharpx.Collections.Experimental.BatchedDeque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option init and the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.unsnoc``1(FSharpx.Collections.Experimental.BatchedDeque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns init and the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.tryUncons``1(FSharpx.Collections.Experimental.BatchedDeque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.uncons``1(FSharpx.Collections.Experimental.BatchedDeque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns the first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.tryGetTail``1(FSharpx.Collections.Experimental.BatchedDeque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option deque of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.tail``1(FSharpx.Collections.Experimental.BatchedDeque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.snoc``1(``0,FSharpx.Collections.Experimental.BatchedDeque{``0})">
<summary>
O(1). Returns a new deque with the element added to the end.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.singleton``1(``0)">
<summary>
O(1). Returns a deque of one element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.rev``1(FSharpx.Collections.Experimental.BatchedDeque{``0})">
<summary>
O(1). Returns deque reversed.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.tryRemove``1(System.Int32,FSharpx.Collections.Experimental.BatchedDeque{``0})">
<summary>
O(n), worst case. Returns option deque with element removed by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.remove``1(System.Int32,FSharpx.Collections.Experimental.BatchedDeque{``0})">
<summary>
O(n), worst case. Returns deque with element removed by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
O(n), worst case. Returns a deque of the seq.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
O(n), worst case. Returns a deque of the list.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.ofCatLists``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
O(n), worst case. Returns a deque of the two lists concatenated.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.tryLookup``1(System.Int32,FSharpx.Collections.Experimental.BatchedDeque{``0})">
<summary>
O(n), worst case. Returns option element by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.lookup``1(System.Int32,FSharpx.Collections.Experimental.BatchedDeque{``0})">
<summary>
O(n), worst case. Returns element by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.length``1(FSharpx.Collections.Experimental.BatchedDeque{``0})">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.tryGetLast``1(FSharpx.Collections.Experimental.BatchedDeque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option last element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.last``1(FSharpx.Collections.Experimental.BatchedDeque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.isEmpty``1(FSharpx.Collections.Experimental.BatchedDeque{``0})">
<summary>
O(1). Returns true if the deque has no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.tryGetInit``1(FSharpx.Collections.Experimental.BatchedDeque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option deque of the elements before the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.init``1(FSharpx.Collections.Experimental.BatchedDeque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque of the elements before the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.tryGetHead``1(FSharpx.Collections.Experimental.BatchedDeque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.head``1(FSharpx.Collections.Experimental.BatchedDeque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.empty``1">
<summary>
O(1). Returns deque of no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedDequeModule.cons``1(``0,FSharpx.Collections.Experimental.BatchedDeque{``0})">
<summary>
O(1). Returns a new deque with the element added to the beginning.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.BatchedDequeModule">

</member>
<member name="M:FSharpx.Collections.Experimental.BatchedQueueModule.tryUncons``1(FSharpx.Collections.Experimental.BatchedQueue{``0})">
<summary>
returns option first element and tail
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedQueueModule.uncons``1(FSharpx.Collections.Experimental.BatchedQueue{``0})">
<summary>
returns the first element and tail
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedQueueModule.tryGetTail``1(FSharpx.Collections.Experimental.BatchedQueue{``0})">
<summary>
returns option queue of the elements trailing the first element
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedQueueModule.tail``1(FSharpx.Collections.Experimental.BatchedQueue{``0})">
<summary>
returns a new queue of the elements trailing the first element
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedQueueModule.snoc``1(``0,FSharpx.Collections.Experimental.BatchedQueue{``0})">
<summary>
returns a new queue with the element added to the end
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedQueueModule.rev``1(FSharpx.Collections.Experimental.BatchedQueue{``0})">
<summary>
returns queue reversed
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedQueueModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
returns a queue of the seq
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedQueueModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
returns a queue of the list
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedQueueModule.length``1(FSharpx.Collections.Experimental.BatchedQueue{``0})">
<summary>
returns the count of elememts
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedQueueModule.isEmpty``1(FSharpx.Collections.Experimental.BatchedQueue{``0})">
<summary>
returns true if the queue has no elements
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedQueueModule.tryGetHead``1(FSharpx.Collections.Experimental.BatchedQueue{``0})">
<summary>
returns option first element
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedQueueModule.head``1(FSharpx.Collections.Experimental.BatchedQueue{``0})">
<summary>
returns the first element
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedQueueModule.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},FSharpx.Collections.Experimental.BatchedQueue{``0},``1)">
<summary>
applies a function to each element of the queue, threading an accumulator argument through the computation, right to left
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedQueueModule.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,FSharpx.Collections.Experimental.BatchedQueue{``1})">
<summary>
applies a function to each element of the queue, threading an accumulator argument through the computation, left to right
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BatchedQueueModule.empty``1">
<summary>
returns queue of no elements
c is front-back stream ration constant, should be at least 2
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.BatchedQueueModule">

</member>
<member name="M:FSharpx.Collections.Experimental.BinaryRandomAccessListModule.tryUpdate``1(System.Int32,``0,FSharpx.Collections.Experimental.BinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns option random access list with element updated by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinaryRandomAccessListModule.update``1(System.Int32,``0,FSharpx.Collections.Experimental.BinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns random access list with element updated by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinaryRandomAccessListModule.tryUncons``1(FSharpx.Collections.Experimental.BinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns the option first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinaryRandomAccessListModule.uncons``1(FSharpx.Collections.Experimental.BinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns the first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinaryRandomAccessListModule.tryGetTail``1(FSharpx.Collections.Experimental.BinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns a option random access list of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinaryRandomAccessListModule.tail``1(FSharpx.Collections.Experimental.BinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns a new random access list of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinaryRandomAccessListModule.rev``1(FSharpx.Collections.Experimental.BinaryRandomAccessList{``0})">
<summary>
O(n). Returns random access list reversed.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinaryRandomAccessListModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
O(n). Returns random access list from the sequence.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinaryRandomAccessListModule.tryLookup``1(System.Int32,FSharpx.Collections.Experimental.BinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns option element by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinaryRandomAccessListModule.lookup``1(System.Int32,FSharpx.Collections.Experimental.BinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns element by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinaryRandomAccessListModule.length``1(FSharpx.Collections.Experimental.BinaryRandomAccessList{``0})">
<summary>
O(log n). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinaryRandomAccessListModule.isEmpty``1(FSharpx.Collections.Experimental.BinaryRandomAccessList{``0})">
<summary>
O(1). Returns true if the random access list has no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinaryRandomAccessListModule.empty``1">
<summary>
O(1). Returns a empty random access list.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinaryRandomAccessListModule.tryGetHead``1(FSharpx.Collections.Experimental.BinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns option first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinaryRandomAccessListModule.head``1(FSharpx.Collections.Experimental.BinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinaryRandomAccessListModule.cons``1(``0,FSharpx.Collections.Experimental.BinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns a new random access list with the element added to the beginning.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.BinaryRandomAccessListModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.BinaryTreeZipper.BinaryTreeZipper`1">
<summary>
 The zipper datastructure for binary trees
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.BinaryTreeZipper.BinaryTree`1">
<summary>
 A simple binary tree
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinaryTreeZipper.move``1(System.Collections.Generic.IEnumerable{FSharpx.Collections.Experimental.BinaryTreeZipper.TreeZipperDirection},FSharpx.Collections.Experimental.BinaryTreeZipper.BinaryTreeZipper{``0})">
<summary>
 Moves the zipper in the directions of the given list
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BinaryTreeZipper.zipper``1(FSharpx.Collections.Experimental.BinaryTreeZipper.BinaryTree{``0})">
<summary>
 Creates a zipper from a tree
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinaryTreeZipper.setFocus``1(FSharpx.Collections.Experimental.BinaryTreeZipper.BinaryTree{``0},FSharpx.Collections.Experimental.BinaryTreeZipper.BinaryTreeZipper{``0})">
<summary>
 Modifies the current focus inside the zipper
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinaryTreeZipper.right``1(FSharpx.Collections.Experimental.BinaryTreeZipper.BinaryTreeZipper{``0})">
<summary>
 Moves the zipper to the right
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinaryTreeZipper.left``1(FSharpx.Collections.Experimental.BinaryTreeZipper.BinaryTreeZipper{``0})">
<summary>
 Moves the zipper to the left
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinaryTreeZipper.top``1(FSharpx.Collections.Experimental.BinaryTreeZipper.BinaryTreeZipper{``0})">
<summary>
 Moves the zipper to the top
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinaryTreeZipper.up``1(FSharpx.Collections.Experimental.BinaryTreeZipper.BinaryTreeZipper{``0})">
<summary>
 Moves the zipper one level up
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinaryTreeZipper.branch``1(``0)">
<summary>
 Creates a new branch with the label x and two leafs as subbranches
</summary>
</member>
<member name="T:FSharpx.Collections.Experimental.BinaryTreeZipper">
<summary>
 TreeZipper
 original implementation taken from http://blog.xquant.net/?p=156
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinomialHeap.tryUncons``1(FSharpx.Collections.Experimental.BinomialHeap{``0})">
<summary>
 O(log n). Returns option head element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinomialHeap.uncons``1(FSharpx.Collections.Experimental.BinomialHeap{``0})">
<summary>
 O(log n). Returns the head element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinomialHeap.tryGetTail``1(FSharpx.Collections.Experimental.BinomialHeap{``0})">
<summary>
O(log n). Returns option heap of the elements trailing the head
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinomialHeap.tail``1(FSharpx.Collections.Experimental.BinomialHeap{``0})">
<summary>
O(log n). Returns a new heap of the elements trailing the head.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinomialHeap.ofSeq``1(System.Boolean,System.Collections.Generic.IEnumerable{``0})">
<summary>
O(log n). Returns heap from the sequence.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinomialHeap.tryMerge``1(FSharpx.Collections.Experimental.BinomialHeap{``0},FSharpx.Collections.Experimental.BinomialHeap{``0})">
<summary>
O(log n). Returns heap option from merging two heaps.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinomialHeap.merge``1(FSharpx.Collections.Experimental.BinomialHeap{``0},FSharpx.Collections.Experimental.BinomialHeap{``0})">
<summary>
O(log n) Returns heap from merging two heaps, both must have same isDescending.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinomialHeap.length``1(FSharpx.Collections.Experimental.BinomialHeap{``0})">
<summary>
O(log n). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinomialHeap.isDescending``1(FSharpx.Collections.Experimental.BinomialHeap{``0})">
<summary>
O(1). Returns true if the heap has max element at head.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinomialHeap.isEmpty``1(FSharpx.Collections.Experimental.BinomialHeap{``0})">
<summary>
O(1). Returns true if the heap has no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinomialHeap.insert``1(``0,FSharpx.Collections.Experimental.BinomialHeap{``0})">
<summary>
O(log n). Returns a new heap with the element inserted.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinomialHeap.tryGetHead``1(FSharpx.Collections.Experimental.BinomialHeap{``0})">
<summary>
O(log n). Returns option first min or max element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinomialHeap.head``1(FSharpx.Collections.Experimental.BinomialHeap{``0})">
<summary>
O(log n). Returns the min or max element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BinomialHeap.empty``1(System.Boolean)">
<summary>
O(1). Returns a empty heap.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.BinomialHeap">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.BootstrappedQueue.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
O(1). Returns a queue of the list.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BootstrappedQueue.length``1(FSharpx.Collections.Experimental.BootstrappedQueue.BootstrappedQueue{``0})">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BootstrappedQueue.tryGetTail``1(FSharpx.Collections.Experimental.BootstrappedQueue.BootstrappedQueue{``0})">
<summary>
O(log* n), worst case. Returns option queue of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BootstrappedQueue.tail``1(FSharpx.Collections.Experimental.BootstrappedQueue.BootstrappedQueue{``0})">
<summary>
O(log* n), worst case. Returns a new queue of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BootstrappedQueue.tryGetHead``1(FSharpx.Collections.Experimental.BootstrappedQueue.BootstrappedQueue{``0})">
<summary>
O(1), worst case.  Returns option first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BootstrappedQueue.head``1(FSharpx.Collections.Experimental.BootstrappedQueue.BootstrappedQueue{``0})">
<summary>
O(1), worst case. Returns the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BootstrappedQueue.snoc``1(``0,FSharpx.Collections.Experimental.BootstrappedQueue.BootstrappedQueue{``0})">
<summary>
O(log* n). Returns a new queue with the element added to the end.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BootstrappedQueue.isEmpty``1(FSharpx.Collections.Experimental.BootstrappedQueue.BootstrappedQueue{``0})">
<summary>
O(1). Returns true if the queue has no elements
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.BootstrappedQueue.empty``1">
<summary>
O(1). Returns queue of no elements.
</summary>
</member>
<member name="T:FSharpx.Collections.Experimental.BootstrappedQueue">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.BottomUpMergeSort">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.DListModule.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,FSharpx.Collections.Experimental.DList{``1})">
<summary>
 Fold walks the DList using constant stack space. Implementation is from Norman Ramsey.
 See http://stackoverflow.com/questions/5324623/functional-o1-append-and-on-iteration-from-first-element-list-data-structure/5334068#5334068
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DListModule.tail``1(FSharpx.Collections.Experimental.DList{``0})">
<summary>
O(log n). Returns a new DList of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DListModule.snoc``1(FSharpx.Collections.Experimental.DList{``0},``0)">
<summary>
O(1). Returns a new DList with the element added to the end.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DListModule.head``1(FSharpx.Collections.Experimental.DList{``0})">
<summary>
O(log n). Returns the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DListModule.append``1(FSharpx.Collections.Experimental.DList{``0},FSharpx.Collections.Experimental.DList{``0})">
<summary>
O(1). Returns a new DList of two lists.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DListModule.cons``1(``0,FSharpx.Collections.Experimental.DList{``0})">
<summary>
O(1). Returns a new DList with the element added to the beginning.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DListModule.toSeq``1(FSharpx.Collections.Experimental.DList{``0})">
<summary>
O(n). Returns a seq of the DList elements.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DListModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
O(n). Returns a DList of the seq.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DListModule.singleton``1(``0)">
<summary>
O(1). Returns DList of one elements.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DListModule.length``1(FSharpx.Collections.Experimental.DList{``0})">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DListModule.isEmpty``1(FSharpx.Collections.Experimental.DList{``0})">
<summary>
O(1). Returns true if the DList has no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DListModule.empty``1">
<summary>
O(1). Returns DList of no elements.
</summary>
</member>
<member name="T:FSharpx.Collections.Experimental.DListModule">

</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.tryUpdate``1(System.Int32,``0,FSharpx.Collections.Experimental.Deque{``0})">
<summary>
O(n), worst case. Returns option deque with element updated by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.update``1(System.Int32,``0,FSharpx.Collections.Experimental.Deque{``0})">
<summary>
O(n), worst case. Returns deque with element updated by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.tryUnsnoc``1(FSharpx.Collections.Experimental.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option init and the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.unsnoc``1(FSharpx.Collections.Experimental.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns init and the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.tryUncons``1(FSharpx.Collections.Experimental.Deque{``0})">
<summary>
O(1) amortized, /O(n), worst case. Returns option first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.uncons``1(FSharpx.Collections.Experimental.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns the first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.tryGetTail``1(FSharpx.Collections.Experimental.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option deque of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.tail``1(FSharpx.Collections.Experimental.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.snoc``1(``0,FSharpx.Collections.Experimental.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque with the element added to the end.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.singleton``1(``0)">
<summary>
O(1). Returns a deque of one element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.rev``1(FSharpx.Collections.Experimental.Deque{``0})">
<summary>
O(1). Returns deque reversed.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.tryRemove``1(System.Int32,FSharpx.Collections.Experimental.Deque{``0})">
<summary>
O(n), worst case. Returns option deque with element removed by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.remove``1(System.Int32,FSharpx.Collections.Experimental.Deque{``0})">
<summary>
O(n), worst case. Returns deque with element removed by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
O(n/2). Returns a deque of the seq.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.ofCatLists``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
O(ys). Returns a deque of the two lists concatenated.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.tryLookup``1(System.Int32,FSharpx.Collections.Experimental.Deque{``0})">
<summary>
O(n), worst case. Returns option element by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.lookup``1(System.Int32,FSharpx.Collections.Experimental.Deque{``0})">
<summary>
O(n), worst case. Returns element by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.length``1(FSharpx.Collections.Experimental.Deque{``0})">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.tryGetLast``1(FSharpx.Collections.Experimental.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option last element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.last``1(FSharpx.Collections.Experimental.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.isEmpty``1(FSharpx.Collections.Experimental.Deque{``0})">
<summary>
O(1). Returns true if the deque has no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.tryGetInit``1(FSharpx.Collections.Experimental.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option deque of the elements before the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.init``1(FSharpx.Collections.Experimental.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns a new deque of the elements before the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.tryGetHead``1(FSharpx.Collections.Experimental.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns option first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.head``1(FSharpx.Collections.Experimental.Deque{``0})">
<summary>
O(1) amortized, O(n), worst case. Returns the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.empty``1">
<summary>
O(1). Returns deque of no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.DequeModule.cons``1(``0,FSharpx.Collections.Experimental.Deque{``0})">
<summary>
O(n), worst case. Returns a new deque with the element added to the beginning.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.DequeModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.Exceptions">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.HeapPriorityQueue">

</member>
<member name="M:FSharpx.Collections.Experimental.HoodMelvilleQueueModule.tryUncons``1(FSharpx.Collections.Experimental.HoodMelvilleQueue{``0})">
<summary>
returns option first element and tail
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.HoodMelvilleQueueModule.uncons``1(FSharpx.Collections.Experimental.HoodMelvilleQueue{``0})">
<summary>
returns the first element and tail
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.HoodMelvilleQueueModule.tryGetTail``1(FSharpx.Collections.Experimental.HoodMelvilleQueue{``0})">
<summary>
returns option queue of the elements trailing the first element
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.HoodMelvilleQueueModule.tail``1(FSharpx.Collections.Experimental.HoodMelvilleQueue{``0})">
<summary>
returns a new queue of the elements trailing the first element
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.HoodMelvilleQueueModule.snoc``1(``0,FSharpx.Collections.Experimental.HoodMelvilleQueue{``0})">
<summary>
returns a new queue with the element added to the end
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.HoodMelvilleQueueModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
returns a queue of the seq
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.HoodMelvilleQueueModule.ofList``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
returns a queue of the list
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.HoodMelvilleQueueModule.length``1(FSharpx.Collections.Experimental.HoodMelvilleQueue{``0})">
<summary>
returns the count of elememts
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.HoodMelvilleQueueModule.isEmpty``1(FSharpx.Collections.Experimental.HoodMelvilleQueue{``0})">
<summary>
returns true if the queue has no elements
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.HoodMelvilleQueueModule.tryGetHead``1(FSharpx.Collections.Experimental.HoodMelvilleQueue{``0})">
<summary>
returns option first element
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.HoodMelvilleQueueModule.head``1(FSharpx.Collections.Experimental.HoodMelvilleQueue{``0})">
<summary>
returns the first element
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.HoodMelvilleQueueModule.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},FSharpx.Collections.Experimental.HoodMelvilleQueue{``0},``1)">
<summary>
applies a function to each element of the queue, threading an accumulator argument through the computation, right to left
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.HoodMelvilleQueueModule.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,FSharpx.Collections.Experimental.HoodMelvilleQueue{``1})">
<summary>
applies a function to each element of the queue, threading an accumulator argument through the computation, left to right
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.HoodMelvilleQueueModule.empty``1">
<summary>
returns queue of no elements
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.HoodMelvilleQueueModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.ImplicitQueue.tryGetTail``1(FSharpx.Collections.Experimental.ImplicitQueue.ImplicitQueue{``0})">
<summary>
O(1), amortized. Returns option queue of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.ImplicitQueue.tail``1(FSharpx.Collections.Experimental.ImplicitQueue.ImplicitQueue{``0})">
<summary>
O(1), amortized. Returns a new queue of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.ImplicitQueue.tryGetHead``1(FSharpx.Collections.Experimental.ImplicitQueue.ImplicitQueue{``0})">
<summary>
O(1), amortized. Returns option first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.ImplicitQueue.head``1(FSharpx.Collections.Experimental.ImplicitQueue.ImplicitQueue{``0})">
<summary>
O(1), amortized. Returns the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.ImplicitQueue.snoc``1(``0,FSharpx.Collections.Experimental.ImplicitQueue.ImplicitQueue{``0})">
<summary>
O(1), amortized. Returns a new queue with the element added to the end.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.ImplicitQueue.isEmpty``1(FSharpx.Collections.Experimental.ImplicitQueue.ImplicitQueue{``0})">
<summary>
O(1). Returns true if the queue has no elements
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.ImplicitQueue.empty``1">
<summary>
O(1). Returns queue of no elements.
</summary>
</member>
<member name="T:FSharpx.Collections.Experimental.ImplicitQueue">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.isProperSubmapOf``1(FSharpx.Collections.Experimental.IntMap{``0},FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(n+m). Is this a proper submap? (ie. a submap but not equal). Defined as (isProperSubmapOf = isProperSubmapOfBy (==)). Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.isProperSubmapOfBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},FSharpx.Collections.Experimental.IntMap{``0},FSharpx.Collections.Experimental.IntMap{``1})">
<summary>
O(n+m). Is this a proper submap? (ie. a submap but not equal). The expression (isProperSubmapOfBy f m1 m2) returns True when m1 and m2 are not equal, all keys in m1 are in m2, and when f returns True when applied to their respective values.  Credit: Haskell.org
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.isSubmapOf``1(FSharpx.Collections.Experimental.IntMap{``0},FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(n+m). Is this a submap? Defined as (isSubmapOf = isSubmapOfBy (==)). Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.isSubmapOfBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},FSharpx.Collections.Experimental.IntMap{``0},FSharpx.Collections.Experimental.IntMap{``1})">
<summary>
O(n+m). The expression (isSubmapOfBy f m1 m2) returns True if all keys in m1 are in m2, and when f returns True when applied to their respective values. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.mapKeysWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32})">
<summary>
O(n*log n). mapKeysWith c f s is the map obtained by applying f to each key of s. The size of the result may be smaller if f maps two or more distinct keys to the same new key. In this case the associated values will be combined using c. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.mapKeys``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32})">
<summary>
O(n*min(n,W)). mapKeys f s is the map obtained by applying f to each key of s. The size of the result may be smaller if f maps two or more distinct keys to the same new key. In this case the value at the greatest of the original keys is retained. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.ofArrayWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Tuple{System.Int32,``0}[])">
<summary>
O(n*min(n,W)). Create a map from an array of key/value pairs with a combining function. See also fromAscListWith. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.ofArrayWithKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},System.Tuple{System.Int32,``0}[])">
<summary>
O(n*min(n,W)). Build a map from an array of key/value pairs with a combining function. See also fromAscListWithKey&apos;. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.ofArray``1(System.Tuple{System.Int32,``0}[])">
<summary>
O(n*min(n,W)). Create a map from an array of key/value pairs. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.ofSeqWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,``0}})">
<summary>
O(n*min(n,W)). Create a map from a seq of key/value pairs with a combining function. See also fromAscListWith. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.ofSeqWithKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,``0}})">
<summary>
O(n*min(n,W)). Build a map from a seq of key/value pairs with a combining function. See also fromAscListWithKey&apos;. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.ofSeq``1(System.Collections.Generic.IEnumerable{System.Tuple{System.Int32,``0}})">
<summary>
O(n*min(n,W)). Create a map from a seq of key/value pairs. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.ofListWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,``0}})">
<summary>
O(n*min(n,W)). Create a map from a list of key/value pairs with a combining function. See also fromAscListWith. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.ofListWithKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,``0}})">
<summary>
O(n*min(n,W)). Build a map from a list of key/value pairs with a combining function. See also fromAscListWithKey&apos;. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.ofList``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,``0}})">
<summary>
O(n*min(n,W)). Create a map from a list of key/value pairs. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.toArray``1(FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(n). Convert the map to an array of key/value pairs. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.toSeq``1(FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(n). Convert the map to a seq of key/value pairs. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.toList``1(FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(n). Convert the map to a list of key/value pairs. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.keys``1(FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(n). Return all keys of the map in ascending order. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.values``1(FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(n). Return all elements of the map in the ascending order of their keys. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.foldWithKey``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``1,``0}}},``0)">
<summary>
O(n). Fold the keys and values in the map, such that foldWithKey f z == Prelude.foldr (uncurry f) z . toAscList. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.foldBackWithKey``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}}},``1,FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(n). FoldBack the keys and values in the map, such that foldWithKey f z == Prelude.foldr (uncurry f) z . toAscList. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0)">
<summary>
O(n). Fold the values in the map, such that fold f z == Prelude.foldr f z . elems. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``1)">
<summary>
O(n). FoldBack the values in the map, such that fold f z == Prelude.foldr f z . elems. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.splitTryFind``1(System.Int32,FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(log n). Performs a split but also returns whether the pivot key was found in the original map. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.split``1(System.Int32,FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(log n). The expression (split k map) is a pair (map1,map2) where all keys in map1 are lower than k and all keys in map2 larger than k. Any key equal to k is found in neither map1 nor map2. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.mapChoice``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}})">
<summary>
O(n). Map values and separate the Left and Right results. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.mapChoiceWithKey``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}}},FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(n). Map keys/values and separate the Left and Right results. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.mapOption``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
<summary>
O(n). Map values and collect the Just results. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.mapOptionWithKey``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}}},FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(n). Map keys/values and collect the Just results. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(n). partition the map according to some predicate. The first map contains all elements that satisfy the predicate, the second all elements that fail the predicate. See also split. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.partitionWithKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(n). partition the map according to some predicate. The first map contains all elements that satisfy the predicate, the second all elements that fail the predicate. See also split. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(n). Filter all values that satisfy some predicate. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.filterWithKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(n). Filter all keys/values that satisfy some predicate. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.mapAccum``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``2}}})">
<summary>
O(n). The function mapAccumWithKey threads an accumulating argument through the map in ascending order of keys. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.mapAccumWithKey``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``2}}}},``0,FSharpx.Collections.Experimental.IntMap{``1})">
<summary>
O(n). The function mapAccum threads an accumulating argument through the map in ascending order of keys. Credit: Haskell.org
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(n). Map a function over all values in the map. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.mapWithKey``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(n). Map a function over all values in the map. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.deleteMax``1(FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(log n). Delete the maximal key. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.deleteMin``1(FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(log n). Delete the minimal key. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.findMax``1(FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(log n). The maximal key of the map. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.findMin``1(FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(log n). The minimal key of the map. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.deleteFindMin``1(FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(log n). Retrieves the minimal key of the map, and the map stripped from that element. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.deleteFindMax``1(FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(log n). Retrieves the maximal key of the map, and the map stripped from that element. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.minView``1(FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(min(n,W)). Retrieves the minimal key of the map, and the map stripped of that element, or Nothing if passed an empty map. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.maxView``1(FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(min(n,W)). Retrieves the maximal key of the map, and the map stripped of that element, or Nothing if passed an empty map. Credit: Haskell.org
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.updateMin``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
O(log n). Update the value at the minimal key. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.updateMax``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
O(log n). Update the value at the maximal key. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.minViewWithKey``1(FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(log n). Retrieves the minimal (key,value) couple of the map, and the map stripped from that element. fails (in the monad) when passed an empty map. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.maxViewWithKey``1(FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(log n). Retrieves the maximal (key,value) couple of the map, and the map stripped from that element. fails (in the monad) when passed an empty map. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.updateMaxWithKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``0}}},FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(log n). Update the value at the maximal key. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.updateMinWithKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``0}}},FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(log n). Update the value at the minimal key. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.intersectionWith``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},FSharpx.Collections.Experimental.IntMap{``0},FSharpx.Collections.Experimental.IntMap{``1})">
<summary>
O(n+m). The intersection with a combining function. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.intersectionWithKey``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},FSharpx.Collections.Experimental.IntMap{``0},FSharpx.Collections.Experimental.IntMap{``1})">
<summary>
O(n+m). The intersection with a combining function. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.intersection``2(FSharpx.Collections.Experimental.IntMap{``0},FSharpx.Collections.Experimental.IntMap{``1})">
<summary>
O(n+m). The (left-biased) intersection of two maps (based on keys). Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.differenceWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``0}}},FSharpx.Collections.Experimental.IntMap{``0},FSharpx.Collections.Experimental.IntMap{``1})">
<summary>
O(n+m). Difference with a combining function. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.differenceWithKey``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``0}}}},FSharpx.Collections.Experimental.IntMap{``0},FSharpx.Collections.Experimental.IntMap{``1})">
<summary>
O(n+m). Difference with a combining function. When two equal keys are encountered, the combining function is applied to the key and both values. If it returns Nothing, the element is discarded (proper set difference). If it returns (Just y), the element is updated with a new value y. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.difference``2(FSharpx.Collections.Experimental.IntMap{``0},FSharpx.Collections.Experimental.IntMap{``1})">
<summary>
O(n+m). Difference between two maps (based on keys). Credit: Haskell.org
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.mergeWithKey``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}}}},Microsoft.FSharp.Core.FSharpFunc{FSharpx.Collections.Experimental.IntMap{``0},FSharpx.Collections.Experimental.IntMap{``2}},Microsoft.FSharp.Core.FSharpFunc{FSharpx.Collections.Experimental.IntMap{``1},FSharpx.Collections.Experimental.IntMap{``2}})">
<summary>
Refer to Haskell documentation. Unexpected code growth or corruption of the data structure can occure from wrong use. Credit: Haskell.org
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.alter``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``0}},System.Int32,FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(log n). The expression (alter f k map) alters the value x at k, or absence thereof. alter can be used to insert, delete, or update a value in an IntMap. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.updateTryFindWithKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``0}}},System.Int32,FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(min(n,W)). Lookup and update. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.adjust``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},System.Int32,FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(min(n,W)). Adjust a value at a specific key. When the key is not a member of the map, the original map is returned. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.adjustWithKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Int32,FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(min(n,W)). Adjust a value at a specific key. When the key is not a member of the map, the original map is returned. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.update``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``0}},System.Int32,FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(min(n,W)). The expression (update f k map) updates the value x at k (if it is in the map). If (f x) is Nothing, the element is deleted. If it is (Just y), the key k is bound to the new value y. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.updateWithKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``0}}},System.Int32,FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(min(n,W)). The expression (update f k map) updates the value x at k (if it is in the map). If (f k x) is Nothing, the element is deleted. If it is (Just y), the key k is bound to the new value y. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.delete``1(System.Int32,FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(min(n,W)). Delete a key and its value from the map. When the key is not a member of the map, the original map is returned. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.insertTryFindWithKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},System.Int32,``0,FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(min(n,W)). The expression (insertLookupWithKey f k x map) is a pair where the first element is equal to (lookup k map) and the second element equal to (insertWithKey f k x map). Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.insertWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Int32,``0,FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(min(n,W)). Insert with a combining function. insertWith f key value mp will insert the pair (key, value) into mp if key does not exist in the map. If the key does exist, the function will insert f new_value old_value. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.insertWithKey``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},System.Int32,``0,FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(min(n,W)). Insert with a combining function. insertWithKey f key value mp will insert the pair (key, value) into mp if key does not exist in the map. If the key does exist, the function will insert f key new_value old_value. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.insert``1(System.Int32,``0,FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(min(n,W)). Insert a new key/value pair in the map. If the key is already present in the map, the associated value is replaced with the supplied value, i.e. insert is equivalent to insertWith const. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.singleton``1(System.Int32,``0)">
<summary>
O(1). A map of one element. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.empty``1">
<summary>
O(1). The empty map. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.tryFindGE``1(System.Int32,FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(log n). Find smallest key greater or equal to the given one and return the corresponding (key, value) pair Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.tryFindLE``1(System.Int32,FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(log n). Find largest key smaller or equal to the given one and return the corresponding (key, value) pair. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.tryFindGT``1(System.Int32,FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(log n). Find smallest key greater than the given one and return the corresponding (key, value) pair. Credit: Haskell.org
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.tryFindLT``1(System.Int32,FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(log n). Find largest key smaller than the given one and return the corresponding (key, value) pair.  Credit: Haskell.org
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.findWithDefault``1(``0,System.Int32,FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(min(n,W)). The expression (findWithDefault def k map) returns the value at key k or returns def when the key is not an element of the map.  Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.find``1(System.Int32,FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(min(n,W)). Lookup the value at a key in the map. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.notExists``1(System.Int32,FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(log n). Is the key not a member of the map? Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.exists``1(System.Int32,FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(min(n,W)). Is the key a member of the map? Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.tryFind``1(System.Int32,FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(min(n,W)). Lookup the value at a key in the map. Returns &apos;a option. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.size``1(FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(n). Number of elements in the map. Credit: Haskell.org
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.IntMap.isEmpty``1(FSharpx.Collections.Experimental.IntMap{``0})">
<summary>
O(1). Map is empty.  Credit: Haskell.org
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.IntMap">

</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IRandomAccessList`1.Uncons">
<summary>
returns the first element and tail
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IRandomAccessList`1.TryUncons">
<summary>
returns the option first element and tail
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IRandomAccessList`1.TryGetTail">
<summary>
returns a option random access list of the elements trailing the first element
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IRandomAccessList`1.TryGetHead">
<summary>
returns option first element 
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IRandomAccessList`1.Tail">
<summary>
returns a new random access list of the elements trailing the first element
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IRandomAccessList`1.IsEmpty">
<summary>
returns true if the random access list has no elements
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IRandomAccessList`1.Head">
<summary>
returns the first element
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IRandomAccessList`1.Update(System.Int32,`0)">
<summary>
returns random access list with element updated by index
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IRandomAccessList`1.TryUpdate(System.Int32,`0)">
<summary>
returns option random access list with element updated by index
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IRandomAccessList`1.TryLookup(System.Int32)">
<summary>
returns option element by index
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IRandomAccessList`1.Rev">
<summary>
returns random access list reversed
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IRandomAccessList`1.Lookup(System.Int32)">
<summary>
returns element by index
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IRandomAccessList`1.Length">
<summary>
returns the count of elememts
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IRandomAccessList`1.Count">
<summary>
returns the count of elememts
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IRandomAccessList`1.Cons(`0)">
<summary>
returns a new random access list with the element added to the beginning
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IPriorityQueue`1.IsEmpty">
<summary>
returns true if the queue has no elements
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IPriorityQueue`1.TryPeek">
<summary>
returns option first element
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IPriorityQueue`1.Pop">
<summary>
returns the first element and tail
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IPriorityQueue`1.Peek">
<summary>
returns the first element
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IPriorityQueue`1.Insert(`0)">
<summary>
returns a new queue with the element added to the end
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IQueue`1.Uncons">
<summary>
returns the first element and tail
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IQueue`1.TryGetTail">
<summary>
returns option queue of the elements trailing the first element
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IQueue`1.TryGetHead">
<summary>
returns option first element
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IQueue`1.Tail">
<summary>
returns a new queue of the elements trailing the first element
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IQueue`1.IsEmpty">
<summary>
returns true if the queue has no elements
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IQueue`1.Head">
<summary>
returns the first element
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IQueue`1.Snoc(`0)">
<summary>
returns a new queue with the element added to the end
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IQueue`1.Length">
<summary>
returns the count of elememts
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IQueue`1.Count">
<summary>
returns the count of elememts
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IHeap`2.Uncons">
<summary>
returns the head element and tail
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IHeap`2.TryUncons">
<summary>
returns option head element and tail
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IHeap`2.TryMerge(`0)">
<summary>
returns heap option from merging two heaps
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IHeap`2.TryGetTail">
<summary>
returns option heap of the elements trailing the head
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IHeap`2.Tail">
<summary>
returns a new heap of the elements trailing the head
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IHeap`2.Merge(`0)">
<summary>
returns heap from merging two heaps, both must have same isDescending
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IHeap`2.Insert(`1)">
<summary>
returns a new heap with the element inserted
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IHeap`1.IsEmpty">
<summary>
returns true if the heap has no elements
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IHeap`1.IsDescending">
<summary>
returns true if the heap has max element at head
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IHeap`1.TryGetHead">
<summary>
returns option first min or max element
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IHeap`1.Length">
<summary>
returns the count of elememts
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IHeap`1.Head">
<summary>
returns the min or max element
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IHeap`1.Count">
<summary>
returns the count of elememts
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IDeque`1.Unsnoc">
<summary>
returns init and the last element
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IDeque`1.Uncons">
<summary>
returns the first element and tail
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IDeque`1.TryUnsnoc">
<summary>
returns option init and the last element
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IDeque`1.TryGetTail">
<summary>
returns option deque of the elements trailing the first element
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IDeque`1.TryGetLast">
<summary>
returns option last element
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IDeque`1.TryGetInit">
<summary>
returns option deque of the elements before the last element
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IDeque`1.TryGetHead">
<summary>
returns option first element
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IDeque`1.Tail">
<summary>
returns a new deque of the elements trailing the first element
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IDeque`1.Rev">
<summary>
returns deque reversed
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IDeque`1.Length">
<summary>
returns the count of elememts
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IDeque`1.Last">
<summary>
returns the last element
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IDeque`1.IsEmpty">
<summary>
returns true if the deque has no elements
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IDeque`1.Init">
<summary>
returns a new deque of the elements before the last element
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IDeque`1.Head">
<summary>
returns the first element
</summary>
</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IDeque`1.Count">
<summary>
returns the count of elememts
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IDeque`1.Update(System.Int32,`0)">
<summary>
returns deque with element updated by index
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IDeque`1.TryUpdate(System.Int32,`0)">
<summary>
returns option deque with element updated by index
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IDeque`1.TryLookup(System.Int32)">
<summary>
returns option element by index
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IDeque`1.Snoc(`0)">
<summary>
returns a new deque with the element added to the end
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IDeque`1.Remove(System.Int32)">
<summary>
returns deque with element removed by index
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IDeque`1.Lookup(System.Int32)">
<summary>
returns element by index
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IDeque`1.Cons(`0)">
<summary>
returns a new deque with the element added to the beginning
</summary>
</member>
<member name="">

</member>
<member name="P:FSharpx.Collections.Experimental.Interfaces.IVector`1.Item(System.Int32)">
<summary>
 Returns the value at the index. If the index is out of bounds it throws an exception.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IVector`1.Pop">
<summary>
 Returns a new vector without the last item. If the collection is empty it throws an exception.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IVector`1.Peek">
<summary>
 Returns the last element in the vector. If the vector is empty it throws an exception.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IVector`1.Count">
<summary>
 Returns the number of items in the collection.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IVector`1.Conj(`0)">
<summary>
 Returns a new vector with the element &apos;added&apos; at the end.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Interfaces.IVector`1.AssocN(System.Int32,`0)">
<summary>
 Returns a new vector that contains the given value at the index. Note - index must be &lt;= vector.Count.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.Interfaces">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.LazyListHelpr">

</member>
<member name="M:FSharpx.Collections.Experimental.LeftistHeapModule.tryUncons``1(FSharpx.Collections.Experimental.LeftistHeap{``0})">
<summary>
O(log n). Returns option head element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.LeftistHeapModule.uncons``1(FSharpx.Collections.Experimental.LeftistHeap{``0})">
<summary>
O(log n). Returns the head element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.LeftistHeapModule.tryGetTail``1(FSharpx.Collections.Experimental.LeftistHeap{``0})">
<summary>
O(log n). Returns option heap of the elements trailing the head.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.LeftistHeapModule.tail``1(FSharpx.Collections.Experimental.LeftistHeap{``0})">
<summary>
O(log n). Returns a new heap of the elements trailing the head.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.LeftistHeapModule.ofSeq``1(System.Boolean,System.Collections.Generic.IEnumerable{``0})">
<summary>
O(log n). Returns heap from the sequence.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.LeftistHeapModule.tryMerge``1(FSharpx.Collections.Experimental.LeftistHeap{``0},FSharpx.Collections.Experimental.LeftistHeap{``0})">
<summary>
O(log n). Returns heap option from merging two heaps.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.LeftistHeapModule.merge``1(FSharpx.Collections.Experimental.LeftistHeap{``0},FSharpx.Collections.Experimental.LeftistHeap{``0})">
<summary>
O(log n). Returns heap from merging two heaps, both must have same isDescending.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.LeftistHeapModule.length``1(FSharpx.Collections.Experimental.LeftistHeap{``0})">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.LeftistHeapModule.isDescending``1(FSharpx.Collections.Experimental.LeftistHeap{``0})">
<summary>
O(1). Returns true if the heap has max element at head.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.LeftistHeapModule.isEmpty``1(FSharpx.Collections.Experimental.LeftistHeap{``0})">
<summary>
O(1). Returns true if the heap has no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.LeftistHeapModule.insert``1(``0,FSharpx.Collections.Experimental.LeftistHeap{``0})">
<summary>
O(log n). Returns a new heap with the element inserted.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.LeftistHeapModule.tryGetHead``1(FSharpx.Collections.Experimental.LeftistHeap{``0})">
<summary>
O(1). Returns option first min or max element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.LeftistHeapModule.head``1(FSharpx.Collections.Experimental.LeftistHeap{``0})">
<summary>
O(1). Returns the min or max element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.LeftistHeapModule.empty``1(System.Boolean)">
<summary>
O(1). Returns a empty heap.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.LeftistHeapModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.ListHelpr">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.ListZipper.ListZipper`1">
<summary>
 A zipper for lists
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.ListZipper.getList``1(FSharpx.Collections.Experimental.ListZipper.ListZipper{``0})">
<summary>
 Returns the whole list from the zipper
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.ListZipper.zipper``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Creates a list zipper
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.ListZipper.front``1(FSharpx.Collections.Experimental.ListZipper.ListZipper{``0})">
<summary>
 Moves the zipper to the front
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.ListZipper.back``1(FSharpx.Collections.Experimental.ListZipper.ListZipper{``0})">
<summary>
 Moves the zipper backwards
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.ListZipper.forward``1(FSharpx.Collections.Experimental.ListZipper.ListZipper{``0})">
<summary>
 Moves the zipper forward
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.ListZipper.modify``1(``0,FSharpx.Collections.Experimental.ListZipper.ListZipper{``0})">
<summary>
 Changes the element under the focus
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.ListZipper.focus``1(FSharpx.Collections.Experimental.ListZipper.ListZipper{``0})">
<summary>
 Returns the head element from the list under focus
</summary>
</member>
<member name="T:FSharpx.Collections.Experimental.ListZipper">
<summary>
 ListZipper
 original implementation taken from http://learnyouahaskell.com/zippers
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PairingHeapModule.tryUncons``1(FSharpx.Collections.Experimental.PairingHeap{``0})">
<summary>
O(log n) amortized time. Returns option head element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PairingHeapModule.uncons``1(FSharpx.Collections.Experimental.PairingHeap{``0})">
<summary>
O(log n) amortized time. Returns the head element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PairingHeapModule.tryGetTail``1(FSharpx.Collections.Experimental.PairingHeap{``0})">
<summary>
O(log n) amortized time. Returns option heap of the elements trailing the head.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PairingHeapModule.tail``1(FSharpx.Collections.Experimental.PairingHeap{``0})">
<summary>
O(log n) amortized time. Returns a new heap of the elements trailing the head.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PairingHeapModule.ofSeq``1(System.Boolean,System.Collections.Generic.IEnumerable{``0})">
<summary>
O(n). Returns heap from the sequence.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PairingHeapModule.tryMerge``1(FSharpx.Collections.Experimental.PairingHeap{``0},FSharpx.Collections.Experimental.PairingHeap{``0})">
<summary>
O(log n) amortized time. Returns heap option from merging two heaps.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PairingHeapModule.merge``1(FSharpx.Collections.Experimental.PairingHeap{``0},FSharpx.Collections.Experimental.PairingHeap{``0})">
<summary>
O(log n) amortized time. Returns heap from merging two heaps, both must have same descending.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PairingHeapModule.length``1(FSharpx.Collections.Experimental.PairingHeap{``0})">
<summary>
O(n). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PairingHeapModule.isDescending``1(FSharpx.Collections.Experimental.PairingHeap{``0})">
<summary>
O(1). Returns true if the heap has max element at head.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PairingHeapModule.isEmpty``1(FSharpx.Collections.Experimental.PairingHeap{``0})">
<summary>
O(1) Returns true if the heap has no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PairingHeapModule.insert``1(``0,FSharpx.Collections.Experimental.PairingHeap{``0})">
<summary>
O(log n) amortized time. Returns a new heap with the element inserted.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PairingHeapModule.tryGetHead``1(FSharpx.Collections.Experimental.PairingHeap{``0})">
<summary>
O(1) worst case. Returns option first min or max element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PairingHeapModule.head``1(FSharpx.Collections.Experimental.PairingHeap{``0})">
<summary>
O(1) worst case. Returns the min or max element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PairingHeapModule.empty``1(System.Boolean)">
<summary>
O(1) Returns a empty heap.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.PairingHeapModule">

</member>
<member name="M:FSharpx.Collections.Experimental.PhysicistQueueModule.tryUncons``1(FSharpx.Collections.Experimental.PhysicistQueue{``0})">
<summary>
O(1), amortized. Returns option first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PhysicistQueueModule.uncons``1(FSharpx.Collections.Experimental.PhysicistQueue{``0})">
<summary>
O(1), amortized. Returns the first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PhysicistQueueModule.tryGetTail``1(FSharpx.Collections.Experimental.PhysicistQueue{``0})">
<summary>
O(1), amortized. Returns option queue of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PhysicistQueueModule.tail``1(FSharpx.Collections.Experimental.PhysicistQueue{``0})">
<summary>
O(1), amortized. Returns a new queue of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PhysicistQueueModule.snoc``1(``0,FSharpx.Collections.Experimental.PhysicistQueue{``0})">
<summary>
O(1), amortized. Returns a new queue with the element added to the end.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PhysicistQueueModule.rev``1(FSharpx.Collections.Experimental.PhysicistQueue{``0})">
<summary>
O(1). Returns queue reversed.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PhysicistQueueModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
O(1). Returns a queue of the seq.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PhysicistQueueModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
O(1). Returns a queue of the list.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PhysicistQueueModule.length``1(FSharpx.Collections.Experimental.PhysicistQueue{``0})">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PhysicistQueueModule.isEmpty``1(FSharpx.Collections.Experimental.PhysicistQueue{``0})">
<summary>
O(1). Returns true if the queue has no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PhysicistQueueModule.tryGetHead``1(FSharpx.Collections.Experimental.PhysicistQueue{``0})">
<summary>
O(1), amortized. Returns option first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PhysicistQueueModule.head``1(FSharpx.Collections.Experimental.PhysicistQueue{``0})">
<summary>
O(1), amortized. Returns the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PhysicistQueueModule.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},FSharpx.Collections.Experimental.PhysicistQueue{``0},``1)">
<summary>
O(n). Applies a function to each element of the queue, threading an accumulator argument through the computation, right to left.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PhysicistQueueModule.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,FSharpx.Collections.Experimental.PhysicistQueue{``1})">
<summary>
O(n). Applies a function to each element of the queue, threading an accumulator argument through the computation, left to right.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.PhysicistQueueModule.empty``1">
<summary>
O(1). Returns queue of no elements.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.PhysicistQueueModule">

</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.tryUpdate``1(System.Int32,``0,FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(n/2), worst case. Returns option deque with element updated by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.update``1(System.Int32,``0,FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(n/2), worst case. Returns deque with element updated by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.tryUnsnoc``1(FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns option init and the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.unsnoc``1(FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns init and the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.tryUncons``1(FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns option first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.uncons``1(FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns the first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.tryGetTail``1(FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns option deque of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.tail``1(FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns a new deque of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.snoc``1(``0,FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns a new deque with the element added to the end.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.singletonC``1(System.Int32,``0)">
<summary>
O(1). Returns a deque of one element, c is front-back stream ratio constant, should be at least 2.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.singleton``1(``0)">
<summary>
O(1). Returns a deque of one element, front-back stream ratio constant defaulted to 2.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.rev``1(FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(1). Returns deque reversed.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.tryRemove``1(System.Int32,FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(n/2), worst case. Returns option deque with element removed by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.remove``1(System.Int32,FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(n/2), worst case. Returns deque with element removed by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.ofSeqC``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
O(n). Returns a deque of the seq, c is front-back stream ratio constant, should be at least 2.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
O(n). Returns a deque of the seq, front-back stream ratio constant defaulted to 2.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.ofCatSeqsC``1(System.Int32,System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
O(|ys-xs|). Returns a deque of the two seqs concatenated, c is front-back stream ratio constant, should be at least 2.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.ofCatSeqs``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
O(|ys-xs|). Returns a deque of the two seqs concatenated, front-back stream ratio constant defaulted to 2.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.ofCatListsC``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
O(|ys-xs|). Returns a deque of the two lists concatenated, c is front-back stream ration constant, should be at least 2.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.ofCatLists``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
O(|ys-xs|). Returns a deque of the two lists concatenated, front-back stream ratio constant defaulted to 2.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.tryLookup``1(System.Int32,FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(n/2), worst case. Returns option element by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.lookup``1(System.Int32,FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(n/2), worst case. Returns option element by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.length``1(FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(1). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.tryGetLast``1(FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns option last element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.last``1(FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.isEmpty``1(FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(1). Returns true if the deque has no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.tryGetInit``1(FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns option deque of the elements before the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.init``1(FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns a new deque of the elements before the last element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.tryGetHead``1(FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns option first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.head``1(FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.empty``1(System.Int32)">
<summary>
O(1). Returns deque of no elements, c is front-back stream ration constant, should be at least 2.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.cons``1(``0,FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(1), worst case. Returns a new deque with the element added to the beginning.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.appendC``1(System.Int32,FSharpx.Collections.Experimental.RealTimeDeque{``0},FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(|ys-xs|). Returns a deque of the two deques concatenated, c is front-back stream ratio constant, should be at least 2.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeDeque.append``1(FSharpx.Collections.Experimental.RealTimeDeque{``0},FSharpx.Collections.Experimental.RealTimeDeque{``0})">
<summary>
O(|ys-xs|). Returns a deque of the two deques concatenated, front-back stream ratio constant defaulted to 2.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.RealTimeDeque">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeQueue.tryGetTail``1(FSharpx.Collections.Experimental.RealTimeQueue.RealTimeQueue{``0})">
<summary>
O(1), worst case. Returns option queue of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeQueue.tail``1(FSharpx.Collections.Experimental.RealTimeQueue.RealTimeQueue{``0})">
<summary>
O(1), worst case. Returns a new queue of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeQueue.tryGetHead``1(FSharpx.Collections.Experimental.RealTimeQueue.RealTimeQueue{``0})">
<summary>
O(1), worst case.  Returns option first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeQueue.head``1(FSharpx.Collections.Experimental.RealTimeQueue.RealTimeQueue{``0})">
<summary>
O(1), worst case. Returns the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeQueue.snoc``1(``0,FSharpx.Collections.Experimental.RealTimeQueue.RealTimeQueue{``0})">
<summary>
O(1), worst case. Returns a new queue with the element added to the end.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeQueue.isEmpty``1(FSharpx.Collections.Experimental.RealTimeQueue.RealTimeQueue{``0})">
<summary>
O(1). Returns true if the queue has no elements
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.RealTimeQueue.empty``1">
<summary>
O(1). Returns queue of no elements.
</summary>
</member>
<member name="T:FSharpx.Collections.Experimental.RealTimeQueue">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.RingBuffer">

</member>
<member name="M:FSharpx.Collections.Experimental.RoseTreeModule.mapAccum``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``2}}},``0,FSharpx.Collections.Experimental.RoseTree{``1})">
<summary>
 Behaves like a combination of map and fold; 
 it applies a function to each element of a tree, 
 passing an accumulating parameter, 
 and returning a final value of this accumulator together with the new tree.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.RoseTreeModule">

</member>
<member name="M:FSharpx.Collections.Experimental.SkewBinaryRandomAccessListModule.tryUpdate``1(System.Int32,``0,FSharpx.Collections.Experimental.SkewBinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns option random access list with element updated by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.SkewBinaryRandomAccessListModule.update``1(System.Int32,``0,FSharpx.Collections.Experimental.SkewBinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns random access list with element updated by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.SkewBinaryRandomAccessListModule.tryUncons``1(FSharpx.Collections.Experimental.SkewBinaryRandomAccessList{``0})">
<summary>
O(1), worst case. Returns the option first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.SkewBinaryRandomAccessListModule.uncons``1(FSharpx.Collections.Experimental.SkewBinaryRandomAccessList{``0})">
<summary>
O(1), worst case. Returns the first element and tail.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.SkewBinaryRandomAccessListModule.tryGetTail``1(FSharpx.Collections.Experimental.SkewBinaryRandomAccessList{``0})">
<summary>
O(1), worst case. Returns a option random access list of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.SkewBinaryRandomAccessListModule.tail``1(FSharpx.Collections.Experimental.SkewBinaryRandomAccessList{``0})">
<summary>
O(1), worst case. Returns a new random access list of the elements trailing the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.SkewBinaryRandomAccessListModule.rev``1(FSharpx.Collections.Experimental.SkewBinaryRandomAccessList{``0})">
<summary>
O(n). Returns random access list reversed.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.SkewBinaryRandomAccessListModule.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
O(n) Returns random access list from the sequence.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.SkewBinaryRandomAccessListModule.tryLookup``1(System.Int32,FSharpx.Collections.Experimental.SkewBinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns option element by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.SkewBinaryRandomAccessListModule.lookup``1(System.Int32,FSharpx.Collections.Experimental.SkewBinaryRandomAccessList{``0})">
<summary>
O(log n), worst case. Returns element by index.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.SkewBinaryRandomAccessListModule.length``1(FSharpx.Collections.Experimental.SkewBinaryRandomAccessList{``0})">
<summary>
O(log n). Returns the count of elememts.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.SkewBinaryRandomAccessListModule.isEmpty``1(FSharpx.Collections.Experimental.SkewBinaryRandomAccessList{``0})">
<summary>
O(1). Returns true if the random access list has no elements.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.SkewBinaryRandomAccessListModule.empty``1">
<summary>
returns a empty random access list.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.SkewBinaryRandomAccessListModule.tryGetHead``1(FSharpx.Collections.Experimental.SkewBinaryRandomAccessList{``0})">
<summary>
O(1), worst case. Returns option first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.SkewBinaryRandomAccessListModule.head``1(FSharpx.Collections.Experimental.SkewBinaryRandomAccessList{``0})">
<summary>
O(1), worst case. Returns the first element.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.SkewBinaryRandomAccessListModule.cons``1(``0,FSharpx.Collections.Experimental.SkewBinaryRandomAccessList{``0})">
<summary>
O(1), worst case. Returns a new random access list with the element added to the beginning.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.SkewBinaryRandomAccessListModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.Vector.assocN``1(System.Int32,``0,FSharpx.Collections.Experimental.Interfaces.IVector{``0})">
<summary>
 Returns a new vector that contains the given value at the index. Note - index must be &lt;= vector.Count.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Vector.pop``1(FSharpx.Collections.Experimental.Interfaces.IVector{``0})">
<summary>
 Returns a new vector without the last item. If the collection is empty it throws an exception.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Vector.peek``1(FSharpx.Collections.Experimental.Interfaces.IVector{``0})">
<summary>
 Returns the last element in the vector. If the vector is empty it throws an exception.
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Vector.conj``1(``0,FSharpx.Collections.Experimental.Interfaces.IVector{``0})">
<summary>
 Returns a new vector with the element &apos;added&apos; at the end.   
</summary>
</member>
<member name="M:FSharpx.Collections.Experimental.Vector.nth``1(System.Int32,FSharpx.Collections.Experimental.Interfaces.IVector{``0})">
<summary>
 Returns the value at the index. If the index is out of bounds it throws an exception.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Collections.Experimental.Vector.count``1(FSharpx.Collections.Experimental.Interfaces.IVector{``0})">
<summary>
 Returns the number of items in the collection.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Experimental.Vector">
<summary>
 vector implementation ported from https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/PersistentVector.java
</summary>
</member>
</members>
</doc>
